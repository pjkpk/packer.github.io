# mysql实现事务
## 原子性：通过undo log来实现
- 在操作任何数据之前，首先将数据备份到一个地方（这个存储数据备份的地方称为Undo Log）,然后进行数据的修改。如果出现了错误或者用户执行了ROLLBACK语句，系统可以利用Undo Log中的备份将数据恢复到事务开始之前的状态。
undo log是逻辑日志，可以理解为是和事务中的操作相反的操作记录。

## 隔离性：通过（读写锁+MVCC）来实现
### Mysql隔离级别
>**读未提交(READ UNCOMMITED)**:对事务处理的读取没有任何限制
>**读已提交(READ COMMITTED)**:解决脏读
>**可重复读(READPEATABLE READ)**:解决不可重复读
>**串行化(SERIALIZABLE)**:解决幻读，强制事务串行执行，这样多个事务互不干扰，不会出现并发一致性问题
![隔离界别](picture/Isolate-Level.png)

### 锁
- mysql中的所分类：
>共享锁
>排他锁

- 锁的粒度
>记录
>表
>数据库

- 基于锁的并发控制流程
1. 事务根据自己对数据项进行的操作类型申请相应的锁（读申请共享锁，写申请排他锁）
2. 申请锁的管理被发送给锁管理器。锁管理器根据当前数据项是否已经有锁以及申请的和持有的锁是否冲突决定是否为该请求授予锁
3. 若锁被授予，则申请锁的事务可以继续执行；若被拒绝，则申请锁的事务将进行等待，直到锁被其他事务释放

-  死锁：多个事务持有锁并互相循环等待其他的事务的锁导致所有事务都无法继续执行。

- 扩展（其他实现并发控制的策略）：
1. 基于时间戳的并发控制
2. 基于有效性检查的并发控制
3. 基于快照隔离的并发控制

### MVCC
多版本并发控制（MVCC）用于实现提交读和可重复读这两种隔离界别。
#### 基本思想

一致性非锁定读：
一致性锁定读
### Next-Key Locks
MVCC+Next-Key Locks可以解决幻读问题。
#### Record Locks
    锁定一个记录上的索引，而不是记录本身。如果表没有设置索引，InnoDB会自动在主键上创建隐藏的聚簇索引，因此Record Locks依然可以使用。
#### Gap Locks
    锁定索引之间的间隙，但是不包含索引本身
#### Next-Key Locks
    不仅锁定一个记录上的索引，也锁定也锁定索引之间的间隙，它锁定一个前开后闭的区间。
## 持久性：通过redo日志实现
- 和Undo Log相反，Redo Log记录的是新数据的备份。**在事务提交前，只要将Redo Log持久化即可，不需要将数据持久化**，当系统崩溃时，虽然数据没有持久化，但是Redo Log已经持久化。系统可以根据Redo Log的内容，将所有数据恢复到最新的状态

## 一致性：原子性 + 隔离性 + 持久性